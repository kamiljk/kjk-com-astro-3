<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Bad Ghost Don't Die Again</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <script src="script.js">const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const scoreDisplay = document.getElementById('score');
const messageDisplay = document.getElementById('message');
const gameContainer = document.querySelector('.game-container');

// --- Game Constants ---
const GHOST_WIDTH = 64;
const GHOST_HEIGHT = 64;
const GRAVITY = 0.15;
const FLAP_STRENGTH = -3;
const WALL_WIDTH = 50;
const GAP_HEIGHT = 100;

function getWallSpeed() {
    return 2 + Math.floor(score / 10);
}

const SPAWN_INTERVAL = 60;

// --- Colors ---
const COLOR_PRIMARY = '#2a6e4f';
const COLOR_ACCENT = '#202020';

// --- Canvas Size ---
// Set initial canvas size - will be properly resized later
canvas.width = 320;
canvas.height = 480;

// --- Game State ---
let ghost;
let obstacles;
let frameCount;
let score;
let gameActive;
let animationFrameId;
let backgroundX = 0;
let difficultyMultiplier = 1;
let ghostFrame = 0;
let ghostAnimationTicker = 0;
const ghostAnimationSpeed = 10;

// --- Ghost Animation Variables ---
let ghostFrameIndex = 0;
const ghostFrameCount = 4;
const ghostFrameWidth = 400;
const ghostFrameHeight = 400;
const ghostSpriteCols = 2;

const ghostSprite = new Image();

// --- Fix: Create a more robust sprite loading system ---
// Instead of relying on a potentially non-existent directory,
// we'll use a default sprite and handle errors more gracefully
ghostSprite.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAL5SURBVHhe7ZpNaxNRFIbHqCtdKLgQXAiCmy7UjeDClaBuFDeCCxeuXLhwI7gRRJ0k/QHiRnDlQheCCxWELgQhUFwUQQShoLQQaSGkkOT4npk7YTqZr5vpzUyT+8DDlHvPPWfeM3duMtMkFAqFQqEnGdKfA3N9frfN5OrHxSr3DgThPmQERLbGZ03m1o9LHR7iU6j/EOXlX2Zs6bMZ//nJTK1tm8m1PXN6850ZXSJ/lJgZXS5zhxeYH7jrU6j3SMHnturmwsaeGYmY1AQX/d0vu/QlMHPkR4gX7Afc67lQf+CSr1XqOgxCYIK8AZnP1nE7yCvAg/BANJbLqseLO1LPuBgT5AvSsjvQQOgM4BXwQiJpnBMY6ylDniAth7K7kCg/ztDjXbYO9LunvAB4AV6QN5zUcQHwwZx6sDRoeQl0Gmi2J0BqnkcDuYL0nZD9+OmH60fKQ6T9mOpRdXgGaDzIzznvOhGRlUXDPePUiR5wAaLH9fIjPAKiuEX1nAeeAZynL34vOMg+0Ovztp/iGYC4fXFHNQc8A+rVh+YE9J5x0fW5/2NAcO9ZF/QEXzVqWi6dIjsGcC/ZnxEy/QZohLfMlX/70bGy6zTZMaDXBj1BXvMHbQRpDGBeyO79onWe6HsD+BGiVd1XAe8IaWNAILydA/IIqPZ5KyDu0hzwnoBPgy0v8gyYSbQGZHqKcA5w3vUcEDQGBO794XacvAbwRgdvdvBmx6kTPeB7RH3UtjFAbncxwMXEqfMegPuuxwDdnrINwKYnbm9FzwG2Adi0mVR9FgNsA7DF7a3oOYBZ3/UYwBZVm8kA2wCuvTvoBthtsw3IbEDeJJr1OweA2yFP8C6R2wBsJgP83APYANfDHuBDoG2zGdDTZoCLCdb5BrRtI5kNcB/iXGN+A1w3GjAD+iEGnMgNUa/IuwbB+eNsQPB+yZcNyJcN6KmMNu52P/5/vaDmr+P/9UKaG/zfbigUCoXyQqHwD/obcibvkLVwAAAAAElFTkSuQmCC';

// Event handlers for sprite loading
ghostSprite.onload = () => {
    // Only redraw if the game is active
    if (gameActive) {
        drawGame();
    }
};

ghostSprite.onerror = () => {
    console.error('Failed to load ghost sprite. Using fallback.');
    // Already using a data URI as fallback, so no additional action needed
};

// --- Particle System ---
let particles = [];

function spawnParticles(x, y) {
    for (let i = 0; i < 3; i++) {
        particles.push({
            x: x + GHOST_WIDTH / 2 + (Math.random() * 10 - 5),
            y: y + GHOST_HEIGHT,
            vx: (Math.random() - 0.5) * 1.5,
            vy: Math.random() * -1,
            alpha: 1,
            size: 2
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05; // gravity
        p.alpha -= 0.02;
        if (p.alpha <= 0) particles.splice(i, 1);
    }
}

function drawParticles() {
    for (const p of particles) {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = COLOR_PRIMARY;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalAlpha = 1;
}

// --- Helper Functions ---
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
}

function drawSpikes(x, y, width, height) {
    const spikeCount = Math.floor(width / 10);
    const spikeWidth = width / spikeCount;
    ctx.fillStyle = COLOR_ACCENT;
    for (let i = 0; i < spikeCount; i++) {
        const spikeX = x + i * spikeWidth;
        ctx.beginPath();
        ctx.moveTo(spikeX, y + height);
        ctx.lineTo(spikeX + spikeWidth / 2, y);
        ctx.lineTo(spikeX + spikeWidth, y + height);
        ctx.closePath();
        ctx.fill();
    }
}

function drawGhost(x, y, width, height) {
    // First draw a fallback rectangle (now more subtle)
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect(x, y, width, height);
    
    // Try to draw the sprite if loaded
    if (ghostSprite.complete && ghostSprite.naturalWidth > 0) {
        try {
            // Fix: Simplified frame calculation to avoid index errors
            const frameIndex = Math.min(ghostFrameIndex, ghostFrameCount - 1);
            const sx = (frameIndex % ghostSpriteCols) * ghostFrameWidth;
            const sy = Math.floor(frameIndex / ghostSpriteCols) * ghostFrameHeight;
            
            ctx.drawImage(
                ghostSprite,
                sx, sy, ghostFrameWidth, ghostFrameHeight,
                x, y, width, height
            );
        } catch (e) {
            // Error already handled by fallback rectangle
        }
    }
}

function resetGame() {
    // Fix: Apply canvas sizing more carefully
    applyCanvasSize();

    ghost = {
        x: canvas.width / 2 - GHOST_WIDTH / 2,
        y: canvas.height / 2,
        width: GHOST_WIDTH,
        height: GHOST_HEIGHT,
        velocity: 0,
        horizontalVelocity: 0
    };
    obstacles = [];
    frameCount = 0;
    score = 0;
    scoreDisplay.textContent = `Score: ${score}`;
    messageDisplay.textContent = '';
    messageDisplay.style.whiteSpace = 'normal';
    scoreDisplay.style.display = 'block';
    gameContainer.classList.remove('game-over');
    gameContainer.classList.add('game-active');
    gameActive = true;
    scoreDisplay.style.color = COLOR_PRIMARY;

    // Cancel previous loop if any, then start new one
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    gameLoop();
}

// Fix: Better canvas sizing function that maintains game proportions
function applyCanvasSize() {
    // Get the available space
    const maxWidth = window.innerWidth;
    const maxHeight = window.innerHeight;
    
    // Set canvas size with a maximum (prevents it from getting too large)
    canvas.width = Math.min(maxWidth, 800);
    canvas.height = Math.min(maxHeight, 600);
}

function resizeCanvas() {
    const previousWidth = canvas.width;
    const previousHeight = canvas.height;
    
    applyCanvasSize();
    
    // Scale game elements proportionally if needed
    if (gameActive && ghost) {
        const widthRatio = canvas.width / previousWidth;
        const heightRatio = canvas.height / previousHeight;
        
        // Update ghost position
        ghost.x = Math.min(ghost.x * widthRatio, canvas.width - ghost.width);
        ghost.y = Math.min(ghost.y * heightRatio, canvas.height - ghost.height);
        
        // Update obstacle positions
        obstacles.forEach(obs => {
            obs.x = Math.min(obs.x * widthRatio, canvas.width);
            obs.y = Math.min(obs.y * heightRatio, canvas.height);
        });
    }
}

function spawnObstacle() {
    const segmentWidth = 80;
    const gapChance = Math.random() < 0.2; // 20% chance of a gap

    if (!gapChance) {
        obstacles.push({
            x: canvas.width,
            y: canvas.height / 2 + GHOST_HEIGHT / 2,
            width: segmentWidth,
            height: 20,
            passed: false
        });
    }
}

// --- Animation State ---
let isClickAnimation = false;
const clickAnimationFrames = [2, 3];
const normalAnimationFrames = [0, 1];

let scoreMultiplier = 1;
let clickCooldown = 0;

function updateGame() {
    if (!gameActive) return;

    // Update ghost animation
    ghostAnimationTicker++;
    if (ghostAnimationTicker % ghostAnimationSpeed === 0) {
        // Fix: Simplified animation frame handling to prevent index errors
        if (isClickAnimation) {
            ghostFrameIndex = clickAnimationFrames[ghostAnimationTicker % 2];
            
            // Reset to normal animation after a short period
            if (ghostAnimationTicker >= ghostAnimationSpeed * 2) {
                isClickAnimation = false;
                ghostAnimationTicker = 0;
            }
        } else {
            ghostFrameIndex = normalAnimationFrames[Math.floor(ghostAnimationTicker / ghostAnimationSpeed) % 2];
        }
    }

    frameCount++;

    // Adjust score logic
    if (clickCooldown > 0) {
        clickCooldown--;
    } else {
        score += 1 * scoreMultiplier;
    }

    if (ghost.velocity > 0) {
        // Ghost is falling, exponentially increase score
        scoreMultiplier = Math.min(scoreMultiplier * 1.05, 10);
    } else {
        // Ghost is rising or stable, reset multiplier
        scoreMultiplier = 1;
    }

    scoreDisplay.textContent = `Score: ${Math.round(score)}`;

    if (frameCount % SPAWN_INTERVAL === 0) {
        spawnObstacle();
    }

    // Move obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].x -= getWallSpeed();
        
        // Remove obstacles that have moved off-screen
        if (obstacles[i].x + obstacles[i].width < 0) {
            obstacles.splice(i, 1);
        }
    }

    let onGround = false;

    // Check if ghost is on a platform
    for (const obs of obstacles) {
        if (
            ghost.x + ghost.width > obs.x &&
            ghost.x < obs.x + obs.width &&
            ghost.y + ghost.height >= obs.y &&
            ghost.y + ghost.height <= obs.y + 10 // Small tolerance for landing
        ) {
            onGround = true;
            ghost.y = obs.y - ghost.height;
            break;
        }
    }

    // Apply physics
    if (!onGround) {
        ghost.velocity += GRAVITY;
        ghost.y += ghost.velocity;
    } else {
        if (ghost.velocity > 2) {
            ghost.velocity = -ghost.velocity * 0.85; // Bounce with damping
        } else {
            ghost.velocity = 0; // Settle when low enough
        }
    }

    // Update horizontal position
    ghost.x += ghost.horizontalVelocity;
    ghost.horizontalVelocity *= 0.9; // Apply friction

    // Ensure ghost stays within canvas bounds
    ghost.x = Math.max(0, Math.min(ghost.x, canvas.width - ghost.width));
    ghost.y = Math.max(0, Math.min(ghost.y, canvas.height - ghost.height));

    // Check if the ghost moves off-screen (now just the bottom since we constrain position)
    if (ghost.y >= canvas.height - ghost.height) {
        endGame();
    }

    // Check Collisions with obstacles
    for (const obs of obstacles) {
        if (
            ghost.x < obs.x + obs.width &&
            ghost.x + ghost.width > obs.x &&
            ghost.y < obs.y + obs.height &&
            ghost.y + ghost.height > obs.y
        ) {
            endGame();
        }
    }
    
    // Update and draw particles
    updateParticles();
}

function endGame() {
    gameActive = false;
    gameContainer.classList.remove('game-active');
    gameContainer.classList.add('game-over');
    scoreDisplay.style.display = 'none';
    messageDisplay.innerHTML = `
        <div class="message-title">
            BAD<br>GHOST<br>DON'T<br>DIE<br><span class="highlight">AGAIN</span>
        </div>
        <div class="message-body">
            Game Over!<br>Score: <span style="color: ${COLOR_PRIMARY};">${Math.round(score)}</span>
            <br>
            <br>Click or Space to Restart
        </div>
    `;
    cancelAnimationFrame(animationFrameId);
}

function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Set background
    ctx.fillStyle = '#333333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw ghost if within bounds
    if (ghost && 
        ghost.x >= 0 && ghost.x + ghost.width <= canvas.width &&
        ghost.y >= 0 && ghost.y + ghost.height <= canvas.height) {
        drawGhost(ghost.x, ghost.y, ghost.width, ghost.height);
    }

    // Draw obstacles
    for (const obs of obstacles) {
        drawSpikes(obs.x, obs.y, obs.width, obs.height);
    }

    // Draw particles
    drawParticles();
}

function gameLoop() {
    if (gameActive) {
        updateGame();
        drawGame();
        animationFrameId = requestAnimationFrame(gameLoop);
    } else {
        cancelAnimationFrame(animationFrameId);
    }
}

// --- Input Handling ---
function handleInput() {
    if (!gameActive) {
        resetGame();
    } else {
        ghost.velocity = FLAP_STRENGTH;
        spawnParticles(ghost.x, ghost.y);
        isClickAnimation = true;
        ghostAnimationTicker = 0; // Reset animation ticker
        ghostFrameIndex = clickAnimationFrames[0];
    }
}

// --- Motion Controls ---
const NUDGE_FORCE = 1;

function handleMouseClick(event) {
    if (!gameActive) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const ghostCenterX = ghost.x + ghost.width / 2;

    if (clickX < ghostCenterX) {
        ghost.horizontalVelocity -= NUDGE_FORCE;
    } else {
        ghost.horizontalVelocity += NUDGE_FORCE;
    }
}

function handleKeyboardInput(event) {
    if (!gameActive) return;

    if (event.code === 'ArrowLeft') {
        ghost.horizontalVelocity -= NUDGE_FORCE;
    } else if (event.code === 'ArrowRight') {
        ghost.horizontalVelocity += NUDGE_FORCE;
    }
}

function handleTouch(event) {
    if (!gameActive) return;

    const rect = canvas.getBoundingClientRect();
    const touchX = event.touches[0].clientX - rect.left;
    const ghostCenterX = ghost.x + ghost.width / 2;

    if (touchX < ghostCenterX) {
        ghost.horizontalVelocity -= NUDGE_FORCE;
    } else {
        ghost.horizontalVelocity += NUDGE_FORCE;
    }
}

// Ensure input listeners are properly set up
function setupInputListeners() {
    // Main control for flapping
    canvas.addEventListener('click', handleInput);
    
    // Directional controls
    canvas.addEventListener('mousedown', handleMouseClick);
    window.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
            event.preventDefault();
            handleInput();
        } else {
            handleKeyboardInput(event);
        }
    });
    
    // Touch controls
    canvas.addEventListener('touchstart', (event) => {
        event.preventDefault();
        handleInput();
        handleTouch(event);
    }, { passive: false });
}

// Add event listener for window resize
window.addEventListener('resize', resizeCanvas);

// Fix the initial setup
function initializeGame() {
    gameContainer.classList.remove('game-active');
    gameContainer.classList.remove('game-over');
    messageDisplay.innerHTML = `
        <div class="message-title">
            BAD<br>GHOST<br>DON'T<br>DIE<br><span class="highlight">AGAIN</span>
        </div>
    `;
    scoreDisplay.style.display = 'none';
    gameActive = false;
    obstacles = [];
    
    // Apply proper canvas sizing
    applyCanvasSize();
    
    // Initialize ghost with proper positioning
    ghost = {
        x: canvas.width / 2 - GHOST_WIDTH / 2,
        y: canvas.height / 2,
        width: GHOST_WIDTH,
        height: GHOST_HEIGHT,
        velocity: 0,
        horizontalVelocity: 0
    };
    
    score = 0;
    frameCount = 0;

    // Add a listener to start the game on the first interaction
    const startGameHandler = () => {
        resetGame();
        window.removeEventListener('keydown', startGameHandler);
        canvas.removeEventListener('click', startGameHandler);
        canvas.removeEventListener('touchstart', startGameHandler);
    };
    
    window.addEventListener('keydown', startGameHandler, { once: true });
    canvas.addEventListener('click', startGameHandler, { once: true });
    canvas.addEventListener('touchstart', startGameHandler, { once: true });

    // Set up input listeners
    setupInputListeners();
    
    // Draw the initial game state
    drawGame();
}

// Call initializeGame to set up the initial state
initializeGame();</script>
  </body>
</html>
